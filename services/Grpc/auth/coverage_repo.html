
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>codec: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sony-nurdianto/farm/auth/internal/encryption/codec/base64.go (100.0%)</option>
				
				<option value="file1">github.com/sony-nurdianto/farm/auth/internal/encryption/passencrypt/password_hash.go (100.0%)</option>
				
				<option value="file2">github.com/sony-nurdianto/farm/auth/internal/models/account.go (0.0%)</option>
				
				<option value="file3">github.com/sony-nurdianto/farm/auth/internal/models/farmer_user.go (0.0%)</option>
				
				<option value="file4">github.com/sony-nurdianto/farm/auth/internal/pbgen/auth.pb.go (27.3%)</option>
				
				<option value="file5">github.com/sony-nurdianto/farm/auth/internal/pbgen/auth_grpc.pb.go (0.0%)</option>
				
				<option value="file6">github.com/sony-nurdianto/farm/auth/internal/repository/create_user_async.go (100.0%)</option>
				
				<option value="file7">github.com/sony-nurdianto/farm/auth/internal/repository/get_user.go (100.0%)</option>
				
				<option value="file8">github.com/sony-nurdianto/farm/auth/internal/repository/repo.go (100.0%)</option>
				
				<option value="file9">github.com/sony-nurdianto/farm/auth/internal/service/service_server.go (100.0%)</option>
				
				<option value="file10">github.com/sony-nurdianto/farm/auth/internal/usecase/usecase.go (100.0%)</option>
				
				<option value="file11">github.com/sony-nurdianto/farm/auth/internal/validator/regiseter_request.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package codec

import "encoding/base64"

//go:generate mockgen -source=base64.go -destination=../../../test/mocks/mock_codec.go -package=mocks
type Base64Encoder interface {
        EncodeToString(src []byte) string
        DecodeString(string) ([]byte, error)
}

type base64encoder struct{}

func NewBase64Encoder() base64encoder <span class="cov8" title="1">{
        return base64encoder{}
}</span>

func (cd base64encoder) EncodeToString(src []byte) string <span class="cov8" title="1">{
        return base64.StdEncoding.EncodeToString(src)
}</span>

func (cd base64encoder) DecodeString(s string) ([]byte, error) <span class="cov8" title="1">{
        return base64.StdEncoding.DecodeString(s)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package passencrypt

import (
        "errors"
        "fmt"
        "io"

        "github.com/sony-nurdianto/farm/auth/internal/encryption/codec"
        "golang.org/x/crypto/argon2"
)

//go:generate mockgen -source=password_hash.go -destination=../../../test/mocks/mock_passencrypt.go -package=mocks
const (
        time    = 1
        memory  = 64 * 1024
        threads = 4
        keyLen  = 32
)

var ErrorGenSaltReadRand = errors.New("failed to read rand")

type PassEncrypt interface {
        HashPassword(password string) (passwordHash string, _ error)
        VerifyPassword(password, passwordHash string) (verify bool, _ error)
}

type passEncrypt struct {
        randRead       io.Reader
        base64Encoding codec.Base64Encoder
}

func NewPassEncrypt(randRead io.Reader, base64Encoding codec.Base64Encoder) passEncrypt <span class="cov8" title="1">{
        return passEncrypt{randRead, base64Encoding}
}</span>

func (pe passEncrypt) HashPassword(
        password string,
) (passwordHash string, _ error) <span class="cov8" title="1">{
        salt := make([]byte, 32)

        _, err := pe.randRead.Read(salt)
        if err != nil </span><span class="cov8" title="1">{
                return passwordHash, err
        }</span>

        <span class="cov8" title="1">hash := argon2.IDKey([]byte(password), salt, time, memory, threads, keyLen)

        saltStr := pe.base64Encoding.EncodeToString(salt)
        hashStr := pe.base64Encoding.EncodeToString(hash)

        passwordHash = fmt.Sprintf("%s%s", hashStr, saltStr)

        return passwordHash, nil</span>
}

func (pe passEncrypt) VerifyPassword(
        password, passwordHash string,
) (verify bool, _ error) <span class="cov8" title="1">{
        salt, err := pe.base64Encoding.DecodeString(passwordHash[44:])
        if err != nil </span><span class="cov8" title="1">{
                return verify, err
        }</span>

        <span class="cov8" title="1">expectedHash, err := pe.base64Encoding.DecodeString(passwordHash[:44])
        if err != nil </span><span class="cov8" title="1">{
                return verify, err
        }</span>

        <span class="cov8" title="1">newHash := argon2.IDKey([]byte(password), salt, time, memory, threads, keyLen)
        verify = string(newHash) == string(expectedHash)

        return verify, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package models

type InsertAccount struct {
        Id       string `avro:"id" json:"id"`
        Email    string `avro:"email" json:"email"`
        Password string `avro:"password_hash" json:"password_hash"`
}

func (InsertAccount) Schema() string <span class="cov0" title="0">{
        return `
                {
                  "type": "record",
                  "name": "InsertAuthAccount",
                  "fields": [
                    {
                      "name": "id",
                      "type": "string",
                      "default": ""
                    },
                    {
                      "name": "email",
                      "type": "string",
                      "default": ""
                    },
                    {
                      "name": "password",
                      "type": "string",
                      "default": ""
                    }
                  ]
                }
        `
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

type InsertFarmerUser struct {
        Id       string `avro:"id" json:"id"`
        FullName string `avro:"full_name" json:"full_name"`
        Email    string `avro:"email" json:"email"`
        Phone    string `avro:"phone" json:"phone"`
}

func (InsertFarmerUser) Schema() string <span class="cov0" title="0">{
        return `
                {
                  "type": "record",
                  "name": "InsertFarmerUser",
                  "fields": [
                    {
                      "name": "id",
                      "type": "string",
                      "default": ""
                    },
                    {
                      "name": "full_name",
                      "type": "string",
                      "default": ""
                    },
                    {
                      "name": "email",
                      "type": "string",
                      "default": ""
                    },
                    {
                      "name": "phone",
                      "type": "string",
                      "default": ""
                    }
                  ]
                }        
        `
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.7
//         protoc        (unknown)
// source: auth/v1/auth.proto

package pbgen

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RegisterRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        FullName      string                 `protobuf:"bytes,1,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
        PhoneNumber   string                 `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
        Email         string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        Password      string                 `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        mi := &amp;file_auth_v1_auth_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_v1_auth_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_v1_auth_proto_rawDescGZIP(), []int{0}
}</span>

func (x *RegisterRequest) GetFullName() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.FullName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPhoneNumber() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.PhoneNumber
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetEmail() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPassword() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Msg           string                 `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
        Status        string                 `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RegisterResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterResponse{}
        mi := &amp;file_auth_v1_auth_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_v1_auth_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_v1_auth_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RegisterResponse) GetMsg() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Msg
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_auth_v1_auth_proto protoreflect.FileDescriptor

const file_auth_v1_auth_proto_rawDesc = "" +
        "\n" +
        "\x12auth/v1/auth.proto\x12\aauth.v1\"\x83\x01\n" +
        "\x0fRegisterRequest\x12\x1b\n" +
        "\tfull_name\x18\x01 \x01(\tR\bfullName\x12!\n" +
        "\fphone_number\x18\x02 \x01(\tR\vphoneNumber\x12\x14\n" +
        "\x05email\x18\x03 \x01(\tR\x05email\x12\x1a\n" +
        "\bpassword\x18\x04 \x01(\tR\bpassword\"&lt;\n" +
        "\x10RegisterResponse\x12\x10\n" +
        "\x03msg\x18\x01 \x01(\tR\x03msg\x12\x16\n" +
        "\x06status\x18\x02 \x01(\tR\x06status2N\n" +
        "\vAuthService\x12?\n" +
        "\bRegister\x12\x18.auth.v1.RegisterRequest\x1a\x19.auth.v1.RegisterResponseb\x06proto3"

var (
        file_auth_v1_auth_proto_rawDescOnce sync.Once
        file_auth_v1_auth_proto_rawDescData []byte
)

func file_auth_v1_auth_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_auth_v1_auth_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_auth_v1_auth_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_auth_v1_auth_proto_rawDesc), len(file_auth_v1_auth_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_auth_v1_auth_proto_rawDescData</span>
}

var file_auth_v1_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_auth_v1_auth_proto_goTypes = []any{
        (*RegisterRequest)(nil),  // 0: auth.v1.RegisterRequest
        (*RegisterResponse)(nil), // 1: auth.v1.RegisterResponse
}
var file_auth_v1_auth_proto_depIdxs = []int32{
        0, // 0: auth.v1.AuthService.Register:input_type -&gt; auth.v1.RegisterRequest
        1, // 1: auth.v1.AuthService.Register:output_type -&gt; auth.v1.RegisterResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_auth_v1_auth_proto_init() }</span>
func file_auth_v1_auth_proto_init() <span class="cov8" title="1">{
        if File_auth_v1_auth_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_auth_v1_auth_proto_rawDesc), len(file_auth_v1_auth_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_auth_v1_auth_proto_goTypes,
                DependencyIndexes: file_auth_v1_auth_proto_depIdxs,
                MessageInfos:      file_auth_v1_auth_proto_msgTypes,
        }.Build()
        File_auth_v1_auth_proto = out.File
        file_auth_v1_auth_proto_goTypes = nil
        file_auth_v1_auth_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: auth/v1/auth.proto

package pbgen

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        AuthService_Register_FullMethodName = "/auth.v1.AuthService/Register"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
}

type authServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient <span class="cov0" title="0">{
        return &amp;authServiceClient{cc}
}</span>

func (c *authServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RegisterResponse)
        err := c.cc.Invoke(ctx, AuthService_Register_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
type AuthServiceServer interface {
        Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
        mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
        mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedAuthServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;AuthService_ServiceDesc, srv)</span>
}

func _AuthService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Register_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "auth.v1.AuthService",
        HandlerType: (*AuthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _AuthService_Register_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "auth/v1/auth.proto",
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package repository

import (
        "context"
        "errors"
        "time"

        "github.com/sony-nurdianto/farm/auth/internal/models"
        "github.com/sony-nurdianto/farm/shared_lib/Go/kafkaev/avr"
        "github.com/sony-nurdianto/farm/shared_lib/Go/kafkaev/kev"
)

func (rp authRepo) publishAvro(
        accountTopic string,
        userTopic string,
        account *models.InsertAccount,
        user *models.InsertFarmerUser,
) error <span class="cov8" title="1">{
        serializer, err := rp.avro.NewGenericSerializer(
                rp.schemaRegisteryClient.Client(),
                avr.ValueSerde,
                avr.NewSerializerConfig(),
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">accountPayload, err := serializer.Serialize(accountTopic, account)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">userPayload, err := serializer.Serialize(userTopic, user)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">accountRecord := kev.MessageKafka{
                TopicPartition: kev.KafkaTopicPartition{
                        Topic:     &amp;accountTopic,
                        Partition: kev.KafkaPartitionAny,
                },
                Value: accountPayload,
        }.Factory()

        userRecord := kev.MessageKafka{
                TopicPartition: kev.KafkaTopicPartition{
                        Topic:     &amp;userTopic,
                        Partition: kev.KafkaPartitionAny,
                },
                Value: userPayload,
        }.Factory()

        ctx, cancel := context.WithTimeout(
                context.Background(),
                time.Millisecond*1000,
        )
        defer cancel()

        if err := rp.authProducer.BeginTransaction(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := rp.authProducer.Produce(&amp;accountRecord, nil); err != nil </span><span class="cov8" title="1">{
                return errors.Join(err, rp.authProducer.AbortTransaction(ctx))
        }</span>

        <span class="cov8" title="1">if err := rp.authProducer.Produce(&amp;userRecord, nil); err != nil </span><span class="cov8" title="1">{
                return errors.Join(err, rp.authProducer.AbortTransaction(ctx))
        }</span>

        <span class="cov8" title="1">return rp.authProducer.CommitTransaction(ctx)</span>
}

func (rp authRepo) CreateUserAsync(
        id, email, fullName, phone, passwordHash string,
) error <span class="cov8" title="1">{
        account := &amp;models.InsertAccount{
                Id:       id,
                Email:    email,
                Password: passwordHash,
        }

        user := &amp;models.InsertFarmerUser{
                Id:       id,
                FullName: fullName,
                Email:    email,
                Phone:    phone,
        }

        accountTopic := "insert-account"
        userTopic := "insert-user"

        return rp.publishAvro(accountTopic, userTopic, account, user)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/sony-nurdianto/farm/auth/internal/entity"
)

func (rp authRepo) GetUserByEmail(email string) (user entity.Users, _ error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(
                context.Background(),
                time.Millisecond*500,
        )

        defer cancel()

        row := rp.getUserByEmailStmt.QueryRowContext(ctx, email)

        err := row.Scan(&amp;user.Id, &amp;user.Email, &amp;user.Password, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov8" title="1">{
                return user, err
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "context"
        "fmt"
        "time"

        "github.com/sony-nurdianto/farm/auth/internal/constants"
        "github.com/sony-nurdianto/farm/auth/internal/entity"
        "github.com/sony-nurdianto/farm/shared_lib/Go/database/postgres/pkg"
        "github.com/sony-nurdianto/farm/shared_lib/Go/kafkaev/avr"
        "github.com/sony-nurdianto/farm/shared_lib/Go/kafkaev/kev"
        "github.com/sony-nurdianto/farm/shared_lib/Go/kafkaev/schrgs"
)

//go:generate mockgen -package=mocks -destination=../../test/mocks/mock_schrgs.go  github.com/sony-nurdianto/farm/shared_lib/Go/kafkaev/schrgs SchemaRegisteryClient,SchemaRegisteryInstance
//go:generate mockgen -package=mocks -destination=../../test/mocks/mock_postgres.go  github.com/sony-nurdianto/farm/shared_lib/Go/database/postgres/pkg PostgresInstance,PostgresDatabase,Stmt,Row
//go:generate mockgen -destination=../../test/mocks/mock_confluent_client.go -package=mocks github.com/confluentinc/confluent-kafka-go/v2/schemaregistry Client
//go:generate mockgen -package=mocks -destination=../../test/mocks/mock_avr.go  github.com/sony-nurdianto/farm/shared_lib/Go/kafkaev/avr AvrSerdeInstance,AvrSerializer,AvrDeserializer
//go:generate mockgen -package=mocks -destination=../../test/mocks/mock_kev.go  github.com/sony-nurdianto/farm/shared_lib/Go/kafkaev/kev Kafka,KevProducer
//go:generate mockgen -package=mocks -destination=../../test/mocks/mock_authrepo.go -source=repo.go

type AuthRepo interface {
        CreateUserAsync(id, email, fullName, phone, passwordHash string) error
        GetUserByEmail(email string) (user entity.Users, _ error)
}

type authRepo struct {
        schemaRegisteryClient schrgs.SchemaRegisteryClient
        avro                  avr.AvrSerdeInstance
        db                    pkg.PostgresDatabase
        createUserstmt        pkg.Stmt
        getUserByEmailStmt    pkg.Stmt
        authProducer          kev.KevProducer
}

func prepareStmt(query string, db pkg.PostgresDatabase) (pkg.Stmt, error) <span class="cov8" title="1">{
        facQuery := fmt.Sprintf(
                query,
                constants.ACCOUNT_TABLE,
        )

        return db.Prepare(facQuery)
}</span>

func initTransactionWithRetry(ctx context.Context, producer kev.KevProducer) error <span class="cov8" title="1">{
        var err error
        counter := 0
        for range 5 </span><span class="cov8" title="1">{
                err = producer.InitTransactions(ctx)
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">time.Sleep(time.Second * 2) // atau exponential backoff bisa dipakai

                counter++</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("init transactions failed after %d attempts: %w", counter, err)</span>
}

func NewAuthRepo(
        sri schrgs.SchemaRegisteryInstance,
        pgi pkg.PostgresInstance,
        avr avr.AvrSerdeInstance,
        kv kev.Kafka,
) (rp authRepo, _ error) <span class="cov8" title="1">{
        db, err := pkg.OpenPostgres("postgres://sony:secret@localhost:5000/auth?sslmode=disable", pgi)
        if err != nil </span><span class="cov8" title="1">{
                return rp, err
        }</span>

        <span class="cov8" title="1">rp.db = db

        crs, err := prepareStmt(constants.QUERY_CREATE_USERS, db)
        if err != nil </span><span class="cov8" title="1">{
                return rp, err
        }</span>

        <span class="cov8" title="1">rp.createUserstmt = crs

        gue, err := prepareStmt(constants.QUERY_GET_USER_BY_EMAIL, db)
        if err != nil </span><span class="cov8" title="1">{
                return rp, err
        }</span>

        <span class="cov8" title="1">rp.getUserByEmailStmt = gue

        cfg := map[kev.ConfigKeyKafka]string{
                kev.BOOTSTRAP_SERVERS:  "localhost:29092",
                kev.ACKS:               "all",
                kev.ENABLE_IDEMPOTENCE: "true",
                kev.COMPRESION_TYPE:    "snappy",
                kev.RETRIES:            "5",
                kev.RETRY_BACKOFF_MS:   "100",
                kev.LINGER_MS:          "5",
                kev.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION: "5",
                kev.TRANSACTIONAL_ID:                      "register-user",
        }

        srgs, err := schrgs.NewSchemaRegistery("http://localhost:8081", sri)
        if err != nil </span><span class="cov8" title="1">{
                return rp, err
        }</span>

        <span class="cov8" title="1">rp.schemaRegisteryClient = srgs.Client()
        rp.avro = avr

        pool := kev.NewKafkaProducerPool(kv, nil)

        producer, err := pool.Producer(cfg)
        if err != nil </span><span class="cov8" title="1">{
                return rp, err
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(
                context.Background(),
                5*time.Second,
        )

        defer cancel()

        if err := initTransactionWithRetry(ctx, producer); err != nil </span><span class="cov8" title="1">{
                return rp, err
        }</span>

        <span class="cov8" title="1">rp.authProducer = producer

        return rp, nil</span>
}

func (rp authRepo) CloseRepo() <span class="cov8" title="1">{
        rp.db.Close()
        rp.authProducer.Close()
        rp.schemaRegisteryClient.Client().Close()
}</span>

// func (rp AuthRepo) CreateUser(email, passwordHash string) (user entity.Users, _ error) {
//         ctx, cancel := context.WithTimeout(
//                 context.Background(),
//                 time.Millisecond*500,
//         )
//         defer cancel()
//
//         userId := uuid.NewString()
//
//         row := rp.createUserstmt.QueryRowContext(ctx, userId, email, passwordHash)
//
//         err := row.Scan(&amp;user.Id, &amp;user.Email, &amp;user.Password, &amp;user.CreatedAt, &amp;user.UpdatedAt)
//         if err != nil {
//                 return user, err
//         }
//
//         return user, nil
// }
//
</pre>
		
		<pre class="file" id="file9" style="display: none">package service

import (
        "context"
        "errors"

        "github.com/sony-nurdianto/farm/auth/internal/pbgen"
        "github.com/sony-nurdianto/farm/auth/internal/usecase"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type AuthServiceServer struct {
        pbgen.UnimplementedAuthServiceServer
        serviceUsecase usecase.ServiceUsecase
}

func NewAuthServiceServer(uc usecase.ServiceUsecase) *AuthServiceServer <span class="cov8" title="1">{
        return &amp;AuthServiceServer{serviceUsecase: uc}
}</span>

func handleRegisterError(err error) error <span class="cov8" title="1">{
        switch </span>{
        case err == usecase.ErrorUserIsExist:<span class="cov8" title="1">
                return status.Error(codes.AlreadyExists, err.Error())</span>
        case errors.Is(err, usecase.ErrorFailedToHasshPassword):<span class="cov8" title="1">
                return status.Error(codes.Internal, err.Error())</span>
        case errors.Is(err, usecase.ErrorRegisterUser):<span class="cov8" title="1">
                return status.Error(codes.Internal, err.Error())</span>
        default:<span class="cov8" title="1">
                return status.Error(codes.Internal, err.Error())</span>
        }
}

func (ass *AuthServiceServer) Register(
        ctx context.Context,
        in *pbgen.RegisterRequest,
) (*pbgen.RegisterResponse, error) <span class="cov8" title="1">{
        res, err := ass.serviceUsecase.UserRegister(in)
        if err != nil </span><span class="cov8" title="1">{
                return nil, handleRegisterError(err)
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package usecase

import (
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/sony-nurdianto/farm/auth/internal/encryption/passencrypt"
        "github.com/sony-nurdianto/farm/auth/internal/pbgen"
        "github.com/sony-nurdianto/farm/auth/internal/repository"
)

var (
        ErrorUserIsExist           error = errors.New("User Is Exist Aborting CreateUser")
        ErrorFailedToHasshPassword error = errors.New("Failed To HashPassword")
        ErrorRegisterUser          error = errors.New("Failed To CreateUserAsync")
)

//go:generate mockgen -package=mocks -destination=../../test/mocks/mock_usecase.go -source=usecase.go
type ServiceUsecase interface {
        UserRegister(user *pbgen.RegisterRequest) (*pbgen.RegisterResponse, error)
}

type serviceUsecase struct {
        authRepo    repository.AuthRepo
        passEncrypt passencrypt.PassEncrypt
}

func NewServiceUsecase(
        repo repository.AuthRepo,
        pass passencrypt.PassEncrypt,
) ServiceUsecase <span class="cov8" title="1">{
        return serviceUsecase{
                authRepo:    repo,
                passEncrypt: pass,
        }
}</span>

func checkUser(rp repository.AuthRepo, email string) (bool, error) <span class="cov8" title="1">{
        _, err := rp.GetUserByEmail(email)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">return false, err</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

func (su serviceUsecase) UserRegister(user *pbgen.RegisterRequest) (*pbgen.RegisterResponse, error) <span class="cov8" title="1">{
        userExsist, err := checkUser(su.authRepo, user.GetEmail())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if userExsist </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrorUserIsExist, err)
        }</span>

        <span class="cov8" title="1">passwordHash, err := su.passEncrypt.HashPassword(user.GetPassword())
        if err != nil </span><span class="cov8" title="1">{
                return nil, ErrorFailedToHasshPassword
        }</span>

        <span class="cov8" title="1">userId := uuid.NewString()

        err = su.authRepo.CreateUserAsync(userId, user.GetEmail(), user.GetFullName(), user.GetPhoneNumber(), passwordHash)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrorRegisterUser, err)
        }</span>

        <span class="cov8" title="1">out := &amp;pbgen.RegisterResponse{
                Msg:    "Success Create User",
                Status: "Success",
        }

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package validator

import (
        "regexp"
        "unicode"
)

func ValidateEmail(email string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
        return re.MatchString(email)
}</span>

func ValidatePhone(phone string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^\+?\d{10,15}$`)
        return re.MatchString(phone)
}</span>

func ValidatePassword(password string) bool <span class="cov8" title="1">{
        if len(password) &lt; 8 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">var hasUpper, hasNumber, hasSpecial bool

        for _, c := range password </span><span class="cov8" title="1">{
                switch </span>{
                case unicode.IsUpper(c):<span class="cov8" title="1">
                        hasUpper = true</span>
                case unicode.IsNumber(c):<span class="cov8" title="1">
                        hasNumber = true</span>
                case unicode.IsPunct(c) || unicode.IsSymbol(c):<span class="cov8" title="1">
                        hasSpecial = true</span>
                }
        }

        <span class="cov8" title="1">return hasUpper &amp;&amp; hasNumber &amp;&amp; hasSpecial</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
